# 什么是回溯法

回溯是递归的副产品，只要有递归就会有回溯。

虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法。 因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。那么既然回溯法并不高效为什么还要用它呢? 因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。

回溯法，一般可以解决如下几种问题:  
* 组合问题:N个数里面按一定规则找出k个数的集合   
* 切割问题:一个字符串按一定规则有几种切割方式   
* 子集问题:一个N个数的集合里有多少符合条件的子集   
* 排列问题:N个数按一定规则全排列，有几种排列方式   
* 棋盘问题:N皇后，解数独等等  

相信大家看着这些之后会发现，每个问题，都不简单!另外，会有一些同学可能分不清什么是组合，什么是排列? 组合是不强调元素顺序的，排列是强调元素顺序。

__回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构! 因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的 树的深度。递归就要有终止条件，所以必然是一颗高度有限的树(N叉树)。__

回溯三部曲: 
1. 回溯函数模板返回值以及参数  
2. 回溯函数终止条件: 既然是树形结构，那么我们在讲解二叉树的递归的时候，就知道遍历树形结构一定要有终止条件。所以回溯也有要终止条件。什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
3. 回溯搜索的遍历过程: 在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

<img src="https://github.com/Lelouch-Lamperouge-Code-Geass/LeetCode/blob/master/Problems%20arranged%20by%20algorithm/Figures/%E5%9B%9E%E6%BA%AF%E6%B3%95%20-%20%E6%A0%91.png">

回溯函数遍历过程伪代码如下:

```
for (选择:本层集合中元素(树中节点孩子的数量就是集合的大小)) { 
  处理节点;
  backtracking(路径，选择列表); // 递归
  回溯，撤销处理结果
}
```

for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。 backtracking这里自己调用自己，实现递归。

大家可以从图中看出__for循环可以理解是横向遍历，backtracking(递归)就是纵向遍历__，这样就把这 棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

分析完过程，回溯算法模板框架如下:

```
void backtracking(参数) { 
  if (终止条件) {
    存放结果;
    return; 
  }
  for (选择:本层集合中元素(树中节点孩子的数量就是集合的大小)) { 
    处理节点;
  } 
}
```

回溯和递归是相辅相成的。

回溯法其实就是暴力查找，并不是什么高效的算法。

回溯法解决的问题都可以抽象为树形结构(N叉树).

# Combinations 组合问题

### Leetcode 77. Combinations

如果n为100，k为50呢，那就50层for循环。 此时就会发现虽然想暴力搜索，但是用for循环嵌套连暴力都写不出来! 要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来 解决嵌套层数的问题。递归来做层叠嵌套(可以理解是开k层for循环)，每一次的递归中嵌套一个for循环，那么递归就可以用 于解决多层嵌套循环的问题了。

每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。 图中可以发现n相当于树的宽度，k相当于树的深度。

那么如何在这个树上遍历，然后收集到我们要的结果集呢? 图中每次搜索到了叶子节点，我们就找到了一个结果。

