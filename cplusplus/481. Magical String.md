A magical string S consists of only '1' and '2' and obeys the following rules:

The string S is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string S itself.

The first few elements of string S is the following: S = "1221121221221121122……"

If we group the consecutive '1's and '2's in S, it will be:

```
1 22 11 2 1 22 1 22 11 2 11 22 ......
```

and the occurrences of '1's or '2's in each group are:

```
1 2	2 1 1 2 1 2 2 1 2 2 ......
```

You can see that the occurrence sequence above is the S itself.

Given an integer N as input, return the number of '1's in the first N number in the magical string S.

__Note:__ N will not exceed 100,000.

#### Example 1:

```
Input: 6
Output: 3
Explanation: The first 6 elements of magical string S is "12211" and it contains three 1's, so return 3.
```

# Solution

### Solution one

The main idea is to build enough of the string and then count.

```cpp
class Solution {
public:
    int magicalString(int n) {
        string magic_str("122");
        int i = 2;
        while (magic_str.size() < n) {
            magic_str += string(magic_str[i++] - '0', magic_str.back() ^ 3);
        }
        return count(magic_str.begin(), magic_str.begin() + n, '1');
    }
};
```

### Solution two

Algorithm for the Kolakoski {1,2}-sequence:


__The Kolakoski {1,2}-sequence may be generated by an algorithm that, in the i-th iteration, reads the value xi that has already been output as the i-th value of the sequence (or, if no such value has been output yet, sets xi = i). Then, if i is odd, it outputs xi copies of the number 1, while if i is even, it outputs xi copies of the number 2.__ Thus, the first few steps of the algorithm are:

1. The first value has not yet been output, so set x1 = 1, and output 1 copy of the number 1
2. The second value has not yet been output, so set x2 = 2, and output 2 copies of the number 2
3. The third value x3 was output as 2 in the second step, so output 2 copies of the number 1.
4. The fourth value x4 was output as 1 in the third step, so output 1 copy of the number 2. Etc.

This algorithm takes linear time, but because it needs to refer back to earlier positions in the sequence it needs to store the whole sequence, taking linear space. An alternative algorithm that generates multiple copies of the sequence at different speeds, with each copy of the sequence using the output of the previous copy to determine what to do at each step, can be used to generate the sequence in linear time and only logarithmic space.

__Why this algorithm works?__

Note that each number(char) int this Kolakoski-01-sequence represents the running length of characters '1' and '2', that is to say, s[i] represents the length of consecutive characters. If we consider each consecutive characters as group, then we know:

__Here index is 1-based, of course we can change it to 0-based.__

```
Here we assume the index is 1-based.

"122112..."
s[1] = '1' : our 1st group has 1 of '1'
s[2] = '2' : our 2nd group has 2 of '2'
s[3] = '2' : our 3rd group has 2 of '1'
s[4] = '1' : our 4-th group has 1 of '2'
....
```

This solution make the string index to be 1-based, in order to match the algorithm described above.

```cpp
class Solution {
public:
    /* 
    Say x is the number that S[i] represents. If i was over the size of S, set x equals to i. 
    Then start the loop. When i is odd, append '1' x times, otherwise append '2' x times. 
    In the end, count how many '1' in S from S.begin() to S.begin() + n + 1. 

    如何生成这个magical string (Kolakoski Sequence)?
    s[i] = "#122";
    如果i是奇数, 则append s[i] 个 1
    如果i是偶数, 则append s[i] 个 2
    最后数一共多少个1.
    trick: s可以加一个空前缀"#", 这样index比较好看, 然后最后记得是s.begin() 到 s.being() + n + 1的范围内.
    */
    
    // Longer but easy to understand.
    int magicalString(int n) {
        string s = "#122";
        for (int i = 3; i <= n; ++i) {
            if (i & 1) { // odd index
                s.append(s[i] - '0', '1');
            } else { // even index
                s.append(s[i] - '0', '2');
            }
        }
        return count(s.begin(), s.begin() + n + 1, '1');
    }
};
```

Here is the solution which index is  0-based. As you can see, we check the index to be odd or even just to make sure we are switching between '1' and '2'.

```cpp
class Solution {
public:

    // Longer but easy to understand.
    int magicalString(int n) {
        string s = "122";
        for (int i = 2; i <= n; ++i) {
            if (i & 1) { // odd index
                s.append(s[i] - '0', '2');
            } else { // even index
                s.append(s[i] - '0', '1');
            }
        }
        return count(s.begin(), s.begin() + n, '1');
    }
};
```


# Knowledge

### Kolakoski sequence

https://en.wikipedia.org/wiki/Kolakoski_sequence

In mathematics, the Kolakoski sequence, sometimes also known as the Oldenburger-Kolakoski sequence, is an infinite sequence of symbols {1,2} that is its own __run-length encoding__ and the prototype for an infinite family of related sequences.

 Kolakoski序列是一个仅由1和2组成的无限数列，是一种通过“自描述”来定义的数列。他在整数数列大全网站上排名第二位，足见该数列在组合数学界中的重要性。他的前几项为：1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2,1,1,…

  它的定义很简单，若把数列中相同的数定为一组，令a(1)=1，a(2)=2，则a(n)等于第n组数的长度。可以根据这个定义来推算第三项以后的数：例如由于a(2)=2，因此第2组数的长度是2，因此a(3)=2,；由于a(3)=2，所以第三组数的长度是2，因此a(4)=a(5)=1；由于a(4)=1，a(5)=1，所以第四组数和第五组数的长度都为1，因此a(6)=2，a(7)=1，以此类推。

  所以我们很容易发现：Kolakoski序列是一个分形数列：即将数列中相邻的数字以其个数合并，得到的仍将是数列本身。

### Run-length encoding

__Run-length encoding (RLE)__ is a very simple form of lossless data compression in which runs of data (that is, sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count, rather than as the original run. This is most useful on data that contains many such runs. Consider, for example, simple graphic images such as icons, line drawings, and animations. It is not useful with files that don't have many runs as it could greatly increase the file size.

#### Example

For example, consider a screen containing plain black text on a solid white background. There will be many long runs of white pixels in the blank space, and many short runs of black pixels within the text. A hypothetical scan line, with B representing a black pixel and W representing white, might read as follows:

```
WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW
```

With a run-length encoding (RLE) data compression algorithm applied to the above hypothetical scan line, it can be rendered as follows:

```
12W1B12W3B24W1B14W
```

This can be interpreted as a sequence of twelve Ws, one B, twelve Ws, three Bs, etc.

The run-length code represents the original 67 characters in only 18. While the actual format used for the storage of images is generally binary rather than ASCII characters like this, the principle remains the same. Even binary data files can be compressed with this method; file format specifications often dictate repeated bytes in files as padding space. However, newer compression methods such as DEFLATE often use LZ77-based algorithms, a generalization of run-length encoding that can take advantage of runs of strings of characters (such as ```BWWBWWBWWBWW```).

Run-length encoding can be expressed in multiple ways to accommodate data properties as well as additional compression algorithms. For instance, one popular method encodes run lengths for runs of two or more characters only, using an "escape" symbol to identify runs, or using the character itself as the escape, so that any time a character appears twice it denotes a run. On the previous example, this would give the following:

```
WW12BWW12BB3WW24BWW14
```

This would be interpreted as a run of twelve Ws, a B, a run of twelve Ws, a run of three Bs, etc. In data where runs are less frequent, this can significantly improve the compression rate.

One other matter is the application of additional compression algorithms. Even with the runs extracted, the frequencies of different characters may be large, allowing for further compression; however, if the run lengths are written in the file in the locations where the runs occurred, the presence of these numbers interrupts the normal flow and makes it harder to compress. To overcome this, some run-length encoders separate the data and escape symbols from the run lengths, so that the two can be handled independently. For the example data, this would result in two outputs, the string "WWBWWBBWWBWW" and the numbers (12,12,3,24,14).

