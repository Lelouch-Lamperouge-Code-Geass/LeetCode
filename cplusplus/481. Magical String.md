A magical string S consists of only '1' and '2' and obeys the following rules:

The string S is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string S itself.

The first few elements of string S is the following: S = "1221121221221121122……"

If we group the consecutive '1's and '2's in S, it will be:

```
1 22 11 2 1 22 1 22 11 2 11 22 ......
```

and the occurrences of '1's or '2's in each group are:

```
1 2	2 1 1 2 1 2 2 1 2 2 ......
```

You can see that the occurrence sequence above is the S itself.

Given an integer N as input, return the number of '1's in the first N number in the magical string S.

__Note:__ N will not exceed 100,000.

#### Example 1:

```
Input: 6
Output: 3
Explanation: The first 6 elements of magical string S is "12211" and it contains three 1's, so return 3.
```

# Solution

### Solution one

The main idea is to build enough of the string and then count.

```cpp
class Solution {
public:
    int magicalString(int n) {
        string magic_str("122");
        int i = 2;
        while (magic_str.size() < n) {
            magic_str += string(magic_str[i++] - '0', magic_str.back() ^ 3);
        }
        return count(magic_str.begin(), magic_str.begin() + n, '1');
    }
};
```

A different style.

```cpp
class Solution {
public:
    /* 
    Say x is the number that S[i] represents. If i was over the size of S, set x equals to i. 
    Then start the loop. When i is odd, append '1' x times, otherwise append '2' x times. 
    In the end, count how many '1' in S from S.begin() to S.begin() + n + 1. 

    如何生成这个magical string (Kolakoski Sequence)?
    s[i] = " 122";
    如果i是奇数, 则append s[i] 个 1
    如果i是偶数, 则append s[i] 个 2
    最后数一共多少个1.
    trick: s可以加一个空前缀" ", 这样index比较好看, 然后最后记得是s.begin() 到 s.being() + n + 1的范围内.
    */
    
    // Longer but easy to understand.
    int magicalString2(int n) {
        string s = " 122";
        for (int i = 3; i <= n; ++i) {
            if (i & 1) { // odd index
                s.append(s[i] - '0', '1');
            } else { // even index
                s.append(s[i] - '0', '2');
            }
        }
        return count(s.begin(), s.begin() + n + 1, '1');
    }
};
```


# Knowledge

### Kolakoski sequence

https://en.wikipedia.org/wiki/Kolakoski_sequence

In mathematics, the Kolakoski sequence, sometimes also known as the Oldenburger-Kolakoski sequence, is an infinite sequence of symbols {1,2} that is its own __run-length encoding__ and the prototype for an infinite family of related sequences.

### Run-length encoding

__Run-length encoding (RLE)__ is a very simple form of lossless data compression in which runs of data (that is, sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count, rather than as the original run. This is most useful on data that contains many such runs. Consider, for example, simple graphic images such as icons, line drawings, and animations. It is not useful with files that don't have many runs as it could greatly increase the file size.

#### Example

For example, consider a screen containing plain black text on a solid white background. There will be many long runs of white pixels in the blank space, and many short runs of black pixels within the text. A hypothetical scan line, with B representing a black pixel and W representing white, might read as follows:

```
WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW
```

With a run-length encoding (RLE) data compression algorithm applied to the above hypothetical scan line, it can be rendered as follows:

```
12W1B12W3B24W1B14W
```

This can be interpreted as a sequence of twelve Ws, one B, twelve Ws, three Bs, etc.

The run-length code represents the original 67 characters in only 18. While the actual format used for the storage of images is generally binary rather than ASCII characters like this, the principle remains the same. Even binary data files can be compressed with this method; file format specifications often dictate repeated bytes in files as padding space. However, newer compression methods such as DEFLATE often use LZ77-based algorithms, a generalization of run-length encoding that can take advantage of runs of strings of characters (such as ```BWWBWWBWWBWW```).

Run-length encoding can be expressed in multiple ways to accommodate data properties as well as additional compression algorithms. For instance, one popular method encodes run lengths for runs of two or more characters only, using an "escape" symbol to identify runs, or using the character itself as the escape, so that any time a character appears twice it denotes a run. On the previous example, this would give the following:

```
WW12BWW12BB3WW24BWW14
```

This would be interpreted as a run of twelve Ws, a B, a run of twelve Ws, a run of three Bs, etc. In data where runs are less frequent, this can significantly improve the compression rate.

One other matter is the application of additional compression algorithms. Even with the runs extracted, the frequencies of different characters may be large, allowing for further compression; however, if the run lengths are written in the file in the locations where the runs occurred, the presence of these numbers interrupts the normal flow and makes it harder to compress. To overcome this, some run-length encoders separate the data and escape symbols from the run lengths, so that the two can be handled independently. For the example data, this would result in two outputs, the string "WWBWWBBWWBWW" and the numbers (12,12,3,24,14).

