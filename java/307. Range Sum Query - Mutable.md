Given an integer array nums, find the sum of the elements between indices i and j (i â‰¤ j), inclusive.

The update(i, val) function modifies nums by updating the element at index i to val.

__Example:__

```
Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8
```

__Note:__

* The array is only modifiable by the update function.  
* You may assume the number of calls to update and sumRange function is distributed evenly.  

# Solution

__Official solution__ : https://leetcode.com/problems/range-sum-query-mutable/solution/


### Solve it with Segment Tree

https://www.youtube.com/watch?v=Ic7OO3Uw6J0

```java
class NumArray {

    class SegmentTreeNode {
        public SegmentTreeNode(int sum, int fromIndex, int toIndex) {
            this.sum = sum;
            this.fromIndex = fromIndex;
            this.toIndex = toIndex;
        }

        public int sum;
        public int fromIndex, toIndex;
        public SegmentTreeNode left, right;
    }

    private SegmentTreeNode rootNode;


    public NumArray(int[] nums) {
        rootNode = buildSegmentTree(nums, 0, nums.length - 1);
    }

    public void update(int i, int val) {
        update(rootNode, i, val);
    }

    public int sumRange(int i, int j) {
        return sumRange(rootNode, i, j);
    }
    
    private SegmentTreeNode buildSegmentTree(final int[] nums, int fromIndex, int toIndex) {
        if (fromIndex > toIndex) {
            return null;
        } else if (fromIndex == toIndex) {
            return new SegmentTreeNode(nums[fromIndex], fromIndex, toIndex);
        } else {
            int midIndex = fromIndex + (toIndex - fromIndex) / 2;
            SegmentTreeNode leftNode = buildSegmentTree(nums, fromIndex, midIndex);
            SegmentTreeNode rightNode = buildSegmentTree(nums, midIndex + 1, toIndex);
            SegmentTreeNode currNode = new SegmentTreeNode(leftNode.sum + rightNode.sum, fromIndex, toIndex);
            currNode.left = leftNode;
            currNode.right = rightNode;
            return currNode;
        }
    }
    
    private int sumRange(final SegmentTreeNode node, int i, int j) {
        if (node.fromIndex == i && node.toIndex == j) {
            return node.sum;
        } else {
            int mid = node.fromIndex + (node.toIndex - node.fromIndex) / 2;
            if (j <= mid) {
                return sumRange(node.left, i, j);
            } else if (i >= mid + 1) {
                return sumRange(node.right, i, j);
            } else {
                return sumRange(node.left, i, mid) + sumRange(node.right, mid + 1, j);
            }
        }
    }
    
    private void update(SegmentTreeNode node, int pos, int val) {
        if (node.fromIndex == node.toIndex) {
           node.sum = val;
        } else {
            int mid = node.fromIndex + (node.toIndex - node.fromIndex) / 2;
            if (pos <= mid) {
                 update(node.left, pos, val);
            } else {
                 update(node.right, pos, val);
            }
            node.sum = node.left.sum + node.right.sum;
        }
    }
}
```

### Solve it with BIT
